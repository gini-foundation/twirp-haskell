# twirp-haskell

Very, very alpha implementation of Twirp service generation for Haskell.

This project provides a number of things:

1. A protoc plugin for generating simple Haskell datatypes for Messages and Enums defined in a proto file.
2. A protoc plugin for generating a Haskell Twirp service (based on Servant) for Services defined in a proto file.
3. A haskell library, `twirp` for quickly serving up the generated application.

An example, end-to-end application is included in `app`.

## Usage

Use the protoc plugin to generate a twirp service and associated protobuf types from a proto file.

```
$ protoc --proto_path=./proto \
  --plugin=protoc-gen-twirp_haskell=./script/run-twirp_haskell --twirp_haskell_out=./app/Twirp/Example \
  --plugin=protoc-gen-haskell=./script/run-haskell --haskell_out=./app/Twirp/Example \
  ./proto/haberdasher.proto
```

You can also install the protoc plugins like so:

```
$ go get github.com/tclem/twirp-haskell/protoc-gen-twirp_haskell
$ go get github.com/tclem/twirp-haskell/protoc-gen-haskell
$ protoc --proto_path=./proto \
  --twirp_haskell_out=./app/Twirp/Example \
  --haskell_out=./app/Twirp/Example \
  ./proto/haberdasher.proto
```

The result is a couple of files that describe your service. First, here are the types that define a Servant API:


``` haskell
-- Code generated by protoc-gen-twirp_haskell 0.1.0, DO NOT EDIT.
{-# LANGUAGE TypeOperators #-}
module Twirp.Example.Haberdasher where

import Servant
import Twirp

import Twirp.Example.HaberdasherPB

type HaberdasherAPI headers
  =    "twirp" :> "twirp.example.haberdasher.Haberdasher" :> HaberdasherService headers
  :<|> "twirp" :> "twirp.example.haberdasher.Health" :> HealthService headers

type HaberdasherService headers
  =    "MakeHat" :> headers :> ReqBody [Protobuf, JSON] Size :> Post '[Protobuf, JSON] Hat
  :<|> "GetBill" :> headers :> ReqBody [Protobuf, JSON] Hat :> Post '[Protobuf, JSON] Bill

type HealthService headers
  =    "Check" :> headers :> ReqBody [Protobuf, JSON] Ping :> Post '[Protobuf, JSON] Pong
```

And here are the data types that represent the protobuf messages:

``` haskell
-- Code generated by protoc-gen-haskell 0.1.0, DO NOT EDIT.
{-# LANGUAGE DerivingVia, DeriveAnyClass, DuplicateRecordFields #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}
module Twirp.Example.HaberdasherPB where

import Data.Aeson
import Data.ByteString (ByteString)
import Data.Fixed (Fixed)
import Data.Int
import Data.Text (Text)
import Data.Word
import GHC.Generics
import Proto3.Suite

data Size = Size
  { inches :: Int32
  } deriving stock (Eq, Ord, Show, Generic)
    deriving anyclass (Message, Named, FromJSON, ToJSON)

data Hat = Hat
  { inches :: Int32
  , color :: Text
  , name :: Text
  } deriving stock (Eq, Ord, Show, Generic)
    deriving anyclass (Message, Named, FromJSON, ToJSON)

data BillExtra
  = VatInfo { vatInfo :: Text }
  | ZipCode { zipCode :: Text }
  deriving stock (Eq, Ord, Show, Generic)
  deriving anyclass (Message, Named, FromJSON, ToJSON)

data Bill = Bill
  { price :: Maybe Price
  , status :: BillingStatus
  , extra :: Maybe BillExtra
  } deriving stock (Eq, Ord, Show, Generic)
    deriving anyclass (Message, Named, FromJSON, ToJSON)

data BillingStatus
  = UnPaid
  | Paid
  deriving stock (Eq, Ord, Show, Enum, Bounded, Generic)
  deriving anyclass (Named, MessageField, FromJSON, ToJSON)
  deriving Primitive via PrimitiveEnum BillingStatus
instance HasDefault BillingStatus where def = UnPaid

data Price = Price
  { dollars :: Word32
  , cents :: Word32
  } deriving stock (Eq, Ord, Show, Generic)
    deriving anyclass (Message, Named, FromJSON, ToJSON)

data Ping = Ping
  { service :: Text
  } deriving stock (Eq, Ord, Show, Generic)
    deriving anyclass (Message, Named, FromJSON, ToJSON)

data Pong = Pong
  { status :: Text
  } deriving stock (Eq, Ord, Show, Generic)
    deriving anyclass (Message, Named, FromJSON, ToJSON)

```

Plugging this into an existing warp/wai server is straightforward. See `app/Main.hs` for the details:

``` haskell
type API = HaberdasherAPI ExpectedHeaders

main :: IO ()
main = run 8003 app

app :: Application
app = twirpErrorResponses apiApp

apiApp :: Application
apiApp = serve (Proxy :: Proxy API) server

server :: Server API
server = (makeHat :<|> getBill) :<|> checkHealth
```
