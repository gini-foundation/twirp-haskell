// This code is heavily inspired by:
// https://github.com/twitchtv/twirp-ruby/blob/master/protoc-gen-twirp_ruby/main.go
// which is licensed under the Apache License, Version 2.0.

package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	// "unicode"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

func main() {
	genReq := readGenRequest(os.Stdin)
	g := &generator{version: Version, genReq: genReq}
	genResp := g.Generate()
	writeGenResponse(os.Stdout, genResp)
}

type generator struct {
	version string
	genReq  *plugin.CodeGeneratorRequest
}

func (g *generator) Generate() *plugin.CodeGeneratorResponse {
	resp := new(plugin.CodeGeneratorResponse)

	for _, f := range g.protoFilesToGenerate() {
		twirpFileName := packageFileName(filePath(f)) + ".hs" // e.g. "hello_world/ServiceTwirp.hs"

		haskellCode := g.generateHaskellCode(f)
		respFile := &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(twirpFileName),
			Content: proto.String(haskellCode),
		}
		resp.File = append(resp.File, respFile)
	}

	return resp
}

func (g *generator) generateHaskellCode(file *descriptor.FileDescriptorProto) string {
	b := new(bytes.Buffer)
	print(b, "-- Code generated by protoc-gen-twirp_haskell %s, DO NOT EDIT.", g.version)
	print(b, "{-# LANGUAGE TypeOperators #-}")

	pkgName := file.GetPackage()
	moduleName := toModuleName(pkgName)
	print(b, "module %s where", moduleName)
	print(b, "")

	print(b, "import Servant")
	print(b, "import Twirp")
	print(b, "")
	print(b, "import %sPB", moduleName)
	print(b, "")

	services := []string{}
	for _, service := range file.Service {
		n := service.GetName()
		services = append(services, fmt.Sprintf("\"%s.%s\" :> %sService headers", pkgName, n, n))
	}
	apis := strings.Join(services, "\n  :<|> ")

	apiName := packageFileName(filePath(file))
	print(b, "type %sAPI headers\n  = \"twirp\" :> %s", apiName, apis)

	for _, service := range file.Service {
		name := service.GetName()
		print(b, "")

		methods := []string{}
		for _, method := range service.GetMethod() {
			n := method.GetName()
			in := toHaskellType(method.GetInputType())
			out := toHaskellType(method.GetOutputType())
			methods = append(methods, fmt.Sprintf("\"%s\" :> headers :> ReqBody [Protobuf, JSON] %s :> Post '[Protobuf, JSON] %s", n, in, out))
		}

		print(b, "type %sService headers\n  = %s", name, strings.Join(methods, " \n  :<|> "))
	}

	return b.String()
}

// .foo.Message => Message
// google.protobuf.Empty => Google.Protobuf.Empty
func toHaskellType(s string) string {
	if len(s) > 1 && s[0:1] == "." {
		parts := strings.Split(s, ".")
		return parts[len(parts)-1]
	}

	parts := []string{}
	for _, x := range strings.Split(s, ".") {
		parts = append(parts, strings.Title(x))
	}
	return strings.Join(parts, ".")
}

// protoFilesToGenerate selects descriptor proto files that were explicitly listed on the command-line.
func (g *generator) protoFilesToGenerate() []*descriptor.FileDescriptorProto {
	files := []*descriptor.FileDescriptorProto{}
	for _, name := range g.genReq.FileToGenerate { // explicitly listed on the command-line
		for _, f := range g.genReq.ProtoFile { // all files and everything they import
			if f.GetName() == name { // match
				files = append(files, f)
				continue
			}
		}
	}
	return files
}

func print(buf *bytes.Buffer, tpl string, args ...interface{}) {
	buf.WriteString(fmt.Sprintf(tpl, args...))
	buf.WriteByte('\n')
}

func filePath(f *descriptor.FileDescriptorProto) string {
	return *f.Name
}

func onlyBase(path string) string {
	return filepath.Base(path)
}

func packageFileName(path string) string {
	ext := filepath.Ext(path)
	return strings.Title(strings.TrimSuffix(path, ext))
}

func toModuleName(pkgName string) string {
	parts := []string{}
	for _, p := range strings.Split(pkgName, ".") {
		parts = append(parts, strings.Title(p))
	}
	return strings.Join(parts, ".")
}

func Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("error:", s)
	os.Exit(1)
}

func readGenRequest(r io.Reader) *plugin.CodeGeneratorRequest {
	data, err := ioutil.ReadAll(r)
	if err != nil {
		Fail(err.Error(), "reading input")
	}

	req := new(plugin.CodeGeneratorRequest)
	if err = proto.Unmarshal(data, req); err != nil {
		Fail(err.Error(), "parsing input proto")
	}

	if len(req.FileToGenerate) == 0 {
		Fail("no files to generate")
	}

	return req
}

func writeGenResponse(w io.Writer, resp *plugin.CodeGeneratorResponse) {
	data, err := proto.Marshal(resp)
	if err != nil {
		Fail(err.Error(), "marshaling response")
	}
	_, err = w.Write(data)
	if err != nil {
		Fail(err.Error(), "writing response")
	}
}
